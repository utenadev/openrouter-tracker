# ハイブリッドデータ取得機能設計書

## 概要

OpenRouterのテーブル形式とリスト形式のデータを組み合わせて、完全なデータセットを取得する機能の設計。

## 現状の問題

1. **テーブル形式（fmt=table）**: 39モデル取得可能だが、週間トークン数なし
2. **リスト形式（fmt=なし）**: 週間トークン数ありだが、r.jina.ai経由では16件しか取得できない

## 解決策

両方の形式を組み合わせて使用する:
1. テーブル形式でメインデータ（39モデル）を取得
2. リスト形式でトークン数（16モデル）を取得
3. モデルIDでデータを統合

## 設計

### 1. 新しいパーサー関数

```python
def parse_list_markdown(markdown: str, logger: logging.Logger) -> List[Dict]:
    """リスト形式Markdownをパースしてモデル情報を抽出"""
    # 週間トークン数、説明、その他の情報を抽出
    # モデルIDをキーにして返す
```

### 2. データ統合関数

```python
def integrate_model_data(table_models: List[Dict], list_models: List[Dict]) -> List[Dict]:
    """テーブル形式とリスト形式のデータを統合"""
    # モデルIDをキーにしてデータを統合
    # 週間トークン数と説明を統合
```

### 3. リスト形式データ取得関数

```python
def fetch_list_markdown(config: Dict, logger: logging.Logger) -> str:
    """リスト形式のMarkdownデータを取得"""
    # fmt=tableを削除したURLを使用
    # 既存のfetch_markdown関数を流用
```

### 4. メイン関数の更新

```python
# テーブル形式データ取得
table_models = parse_markdown(markdown, logger)

# リスト形式データ取得
try:
    list_markdown = fetch_list_markdown(config, logger)
    list_models = parse_list_markdown(list_markdown, logger)
    
    # データ統合
    models_data = integrate_model_data(table_models, list_models)
except Exception as e:
    # リスト形式取得失敗時はテーブル形式のみ使用
    models_data = table_models
```

## 実装手順

### フェーズ1: リスト形式パーサーの実装
1. `LIST_MODEL_PATTERN`などのパターンを定義
2. `parse_list_markdown()`関数を実装
3. テストデータで動作確認

### フェーズ2: データ統合関数の実装
1. `integrate_model_data()`関数を実装
2. モデルIDの正規化関数を実装
3. テストデータで動作確認

### フェーズ3: リスト形式データ取得関数の実装
1. `fetch_list_markdown()`関数を実装
2. URLの切り替えロジックを実装
3. テストデータで動作確認

### フェーズ4: メイン関数の更新
1. メイン関数に統合ロジックを追加
2. エラーハンドリングを実装
3. 本番データで動作確認

## 予想される課題と解決策

### 1. モデルIDの不一致
- **問題**: テーブル形式とリスト形式でID形式が異なる可能性
- **解決策**: IDの正規化関数を実装

### 2. データの欠落
- **問題**: リスト形式で取得できるモデルが少ない
- **解決策**: 取得できないモデルにはデフォルト値を設定

### 3. パフォーマンス
- **問題**: 2回のAPI呼び出しが必要
- **解決策**: キャッシュ機能を実装

### 4. エラーハンドリング
- **問題**: リスト形式取得失敗時の対応
- **解決策**: テーブル形式のみ使用するフォールバック

## テスト計画

### 1. 単体テスト
- リスト形式パーサーのテスト
- データ統合関数のテスト
- リスト形式データ取得関数のテスト

### 2. 統合テスト
- メイン関数のテスト
- エラーハンドリングのテスト
- フォールバックのテスト

### 3. 本番テスト
- 実際のAPIで動作確認
- パフォーマンス測定
- エラーケースの確認

## 実装の優先順位

1. **リスト形式パーサーの実装** (最優先)
2. **データ統合ロジックの実装** (優先度高)
3. **エラーハンドリングの強化** (優先度中)
4. **パフォーマンス最適化** (優先度低)

## 実装の注意点

1. **後方互換性**: 既存のコードと互換性を維持
2. **エラーハンドリング**: 堅牢なエラーハンドリングを実装
3. **パフォーマンス**: API呼び出し回数を最小限に抑える
4. **テスト**: 十分なテストを実施

## 実装のメリット

1. **完全なデータ**: 39モデルの完全なデータを取得
2. **柔軟性**: 片方の形式が失敗しても動作
3. **拡張性**: 新しい形式にも対応可能
4. **信頼性**: データの信頼性向上

## 実装のデメリット

1. **複雑性**: コードの複雑性が増加
2. **パフォーマンス**: API呼び出し回数が増加
3. **メンテナンス**: メンテナンスコストが増加

## 結論

ハイブリッドデータ取得機能は、テーブル形式とリスト形式の利点を組み合わせることで、完全なデータセットを取得できるようになります。段階的な実装と十分なテストが重要です。